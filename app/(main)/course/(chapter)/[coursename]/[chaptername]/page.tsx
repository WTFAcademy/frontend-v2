"use client";

import ChapterDetailFooter from "@/features/course/components/chapter-detail-footer";
import ChapterDetailHeader from "@/features/course/components/chapter-detail-header";
import { useMobileReaderInteraction } from "@/features/course/hooks/use-mobile-reader-interaction";
import ChapterRenderer from "@/features/course/components/chapter-renderer";

const content = "我最近在重新学 Solidity，巩固一下细节，也写一个“WTF Solidity极简入门”，供小白们使用（编程大佬可以另找教程），每周更新 1-3 讲。\n\n推特：[@0xAA_Science](https://twitter.com/0xAA_Science)｜[@WTFAcademy_](https://twitter.com/WTFAcademy_)\n\n社区：[Discord](https://discord.gg/5akcruXrsk)｜[微信群](https://docs.google.com/forms/d/e/1FAIpQLSe4KGT8Sh6sJ7hedQRuIYirOoZK_85miz3dw7vA1-YjodgJ-A/viewform?usp=sf_link)｜[官网 wtf.academy](https://wtf.academy)\n\n所有代码和教程开源在 github: [github.com/AmazingAng/WTF-Solidity](https://github.com/AmazingAng/WTF-Solidity)\n\n---\n\n## Solidity中的引用类型\n\n**引用类型(Reference Type)**：包括数组（`array`）和结构体（`struct`），由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\n\n## 数据位置\n\nSolidity数据存储位置有三类：`storage`，`memory`和`calldata`。不同存储位置的`gas`成本不同。`storage`类型的数据存在链上，类似计算机的硬盘，消耗`gas`多；`memory`和`calldata`类型的临时存在内存里，消耗`gas`少。大致用法：\n\n1. `storage`：合约里的状态变量默认都是`storage`，存储在链上。\n\n2. `memory`：函数里的参数和临时变量一般用`memory`，存储在内存中，不上链。尤其是如果返回数据类型是变长的情况下，必须加memory修饰，例如：string, bytes, array和自定义结构。\n\n3. `calldata`：和`memory`类似，存储在内存中，不上链。与`memory`的不同点在于`calldata`变量不能修改（`immutable`），一般用于函数的参数。例子：\n\n```solidity\nfunction fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\n    //参数为calldata数组，不能被修改\n    // _x[0] = 0 //这样修改会报错\n    return(_x);\n}\n```\n\n**Example:**\n\n![5-1.png](https://s3.ap-northeast-1.amazonaws.com/image.wtf/course/b397b502f088d34dad8eff7be5670210.png%3Fraw%3Dtrue)\n\n### 数据位置和赋值规则\n\n在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\n\n- 赋值本质上是创建**引用**指向本体，因此修改本体或者是引用，变化可以被同步：\n\n  - `storage`（合约的状态变量）赋值给本地`storage`（函数里的）时候，会创建引用，改变新变量会影响原变量。例子：\n  \n    ```solidity\n    uint[] x = [1,2,3]; // 状态变量：数组 x\n\n    function fStorage() public{\n        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\n        uint[] storage xStorage = x;\n        xStorage[0] = 100;\n    }\n    ```\n\n    **Example:**\n\n    ![5-2.png](https://s3.ap-northeast-1.amazonaws.com/image.wtf/course/7b28744dddb57264a6373f873f331a1e.png%3Fraw%3Dtrue)\n  - `memory`赋值给`memory`，会创建引用，改变新变量会影响原变量。\n\n- 其他情况下，赋值创建的是本体的副本，即对二者之一的修改，并不会同步到另一方\n\n## 变量的作用域\n\n`Solidity`中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)\n\n### 1. 状态变量\n\n状态变量是数据存储在链上的变量，所有合约内函数都可以访问，`gas`消耗高。状态变量在合约内、函数外声明：\n\n```solidity\ncontract Variables {\n    uint public x = 1;\n    uint public y;\n    string public z;\n}\n```\n\n我们可以在函数里更改状态变量的值：\n\n```solidity\nfunction foo() external{\n    // 可以在函数里更改状态变量的值\n    x = 5;\n    y = 2;\n    z = \"0xAA\";\n}\n```\n\n### 2. 局部变量\n\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，`gas`低。局部变量在函数内声明：\n\n```solidity\nfunction bar() external pure returns(uint){\n    uint xx = 1;\n    uint yy = 3;\n    uint zz = xx + yy;\n    return(zz);\n}\n```\n\n### 3. 全局变量\n\n全局变量是全局范围工作的变量，都是`solidity`预留关键字。他们可以在函数内不声明直接使用：\n\n```solidity\nfunction global() external view returns(address, uint, bytes memory){\n    address sender = msg.sender;\n    uint blockNum = block.number;\n    bytes memory data = msg.data;\n    return(sender, blockNum, data);\n}\n```\n\n在上面例子里，我们使用了3个常用的全局变量：`msg.sender`，`block.number`和`msg.data`，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个[链接](https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions)：\n\n- `blockhash(uint blockNumber)`: (`bytes32`) 给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。\n- `block.coinbase`: (`address payable`) 当前区块矿工的地址\n- `block.gaslimit`: (`uint`) 当前区块的gaslimit\n- `block.number`: (`uint`) 当前区块的number\n- `block.timestamp`: (`uint`) 当前区块的时间戳，为unix纪元以来的秒\n- `gasleft()`: (`uint256`) 剩余 gas\n- `msg.data`: (`bytes calldata`) 完整call data\n- `msg.sender`: (`address payable`) 消息发送者 (当前 caller)\n- `msg.sig`: (`bytes4`) calldata的前四个字节 (function identifier)\n- `msg.value`: (`uint`) 当前交易发送的 `wei` 值\n- `block.blobbasefee`: (`uint`) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。\n- `blobhash(uint index)`: (`bytes32`) 返回跟当前交易关联的第 `index` 个blob的版本化哈希（第一个字节为版本号，当前为`0x01`，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。\n\n\n**Example:**\n\n![5-4.png](https://s3.ap-northeast-1.amazonaws.com/image.wtf/course/a8f8ded6001420742b9dcd79a6d02184.png%3Fraw%3Dtrue)\n\n### 4. 全局变量-以太单位与时间单位\n\n#### 以太单位\n\n`Solidity`中不存在小数点，以`0`代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。\n\n- `wei`: 1\n- `gwei`: 1e9 = 1000000000\n- `ether`: 1e18 = 1000000000000000000\n\n```solidity\nfunction weiUnit() external pure returns(uint) {\n    assert(1 wei == 1e0);\n    assert(1 wei == 1);\n    return 1 wei;\n}\n\nfunction gweiUnit() external pure returns(uint) {\n    assert(1 gwei == 1e9);\n    assert(1 gwei == 1000000000);\n    return 1 gwei;\n}\n\nfunction etherUnit() external pure returns(uint) {\n    assert(1 ether == 1e18);\n    assert(1 ether == 1000000000000000000);\n    return 1 ether;\n}\n```\n\n**Example:**\n\n![5-5.png](https://s3.ap-northeast-1.amazonaws.com/image.wtf/course/1bed4cf5957d973186a0acb26c062377.png%3Fraw%3Dtrue)\n\n#### 时间单位\n\n可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在`Solidity`中是一个重要的概念，有助于提高合约的可读性和可维护性。\n\n- `seconds`: 1\n- `minutes`: 60 seconds = 60\n- `hours`: 60 minutes = 3600\n- `days`: 24 hours = 86400\n- `weeks`: 7 days = 604800\n\n```solidity\nfunction secondsUnit() external pure returns(uint) {\n    assert(1 seconds == 1);\n    return 1 seconds;\n}\n\nfunction minutesUnit() external pure returns(uint) {\n    assert(1 minutes == 60);\n    assert(1 minutes == 60 seconds);\n    return 1 minutes;\n}\n\nfunction hoursUnit() external pure returns(uint) {\n    assert(1 hours == 3600);\n    assert(1 hours == 60 minutes);\n    return 1 hours;\n}\n\nfunction daysUnit() external pure returns(uint) {\n    assert(1 days == 86400);\n    assert(1 days == 24 hours);\n    return 1 days;\n}\n\nfunction weeksUnit() external pure returns(uint) {\n    assert(1 weeks == 604800);\n    assert(1 weeks == 7 days);\n    return 1 weeks;\n}\n```\n\n**Example:**\n\n![5-6.png](https://s3.ap-northeast-1.amazonaws.com/image.wtf/course/91457ac5faf354b467d42a9f083812f5.png%3Fraw%3Dtrue)\n\n## 总结\n\n在这一讲，我们介绍了`Solidity`中的引用类型，数据位置和变量的作用域。重点是`storage`, `memory`和`calldata`三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低`gas`。下一讲我们会介绍引用类型中的数组。\n"

const CourseChapterPage = ({
  params,
}: {
  params: { coursename: string; chaptername: string };
}) => {
  console.log(params);
  const { containerRef, scrollRef } =
    useMobileReaderInteraction();

  return (
    <div className="relative flex-auto overflow-y-auto pt-20" ref={scrollRef}>
      <div className="p-10" ref={containerRef}>
        <ChapterDetailHeader
          title="WTF Solidity: 2. Value Type"
          studyTime={20}
          bestScore={100}
        />
        <ChapterRenderer>{content}</ChapterRenderer>
      </div>
      <ChapterDetailFooter />
    </div>
  );
};

export default CourseChapterPage;
